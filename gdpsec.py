# -*- coding: utf-8 -*-
"""GDPsec.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13Y75yfzqb2Ue39IeUnM-Yv2Im4GZcGQg

# Packages
"""

import numpy as np
import pandas as pd
from pandas import Series
from pandas import DataFrame
import matplotlib.pyplot as plt
import matplotlib
import seaborn as sns
plt.rc('figure', figsize=(12, 9))
np.set_printoptions(precision=4, suppress=True)

import urllib.request
import shutil

# Packages used in Chapter I.III and II.I for Choropleth Maps
import plotly.express as px

# Packages used in Chapter II.II in order to downloead data from OECD website
!pip install pandasdmx
import pandasdmx as pdmx

# Packages used in Chapter IV for Linear Regression and Classification
from sklearn import metrics
from sklearn.metrics import classification_report
from sklearn import model_selection
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import LogisticRegression
from sklearn.datasets import make_classification
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC

"""# I° Chapter

## I.I. Datasets

### Emissions Dataset

The main dataset we will use contains the reported GHG emissions by european countries. The emissions are reported by country, pollutant, sector and year.
"""

# We download the dataset from EEA website, it's a 90MB csv file

url_emissions = "https://sdi.eea.europa.eu/datashare/s/nQm7mfWywfyLdLX/download"
!mkdir GLEMfolder
urllib.request.urlretrieve(url_emissions,"GLEMfolder/filesGLEM.zip")
shutil.unpack_archive("GLEMfolder/filesGLEM.zip","./GLEMfolder")

file_path = "./GLEMfolder/eea_t_national-emissions-reported_p_2023_v01_r01"
emissions_df = pd.read_csv(file_path + "/UNFCCC_v26.csv")

# We get a warning. The problem is that some rows have a range of years '1985-1987' instead of a single year
# Some years are read as integers, some as strings
print(emissions_df.columns[8])
display(emissions_df.Year.unique())

# For now we convert all entries for Year to strings
emissions_df.Year = emissions_df.Year.astype(str)
emissions_df.Year.unique()

emissions_df.info()

# Full information about the reporting format can be found here:
# https://www.ipcc-nggip.iges.or.jp/public/2006gl/pdf/1_Volume1/V1_8_Ch8_Reporting_Guidance.pdf

emissions_df.Year.value_counts().sort_index()
# Data from 1989 and before is incomplete, we will start our analysis from 1990

mask = emissions_df.Year.isin(["1985","1985-1987","1986","1987","1988","1989"])
emissions_df = emissions_df[~mask]

# Now that we removed the years that gave us problems we can turn the strings back into integers
emissions_df["Year"] = emissions_df.Year.astype("int32")
emissions_df.Year.dtype

emissions_df.isnull().sum()

emissions_df.Notation.value_counts()

"""The meaning is:
+ NE: not estimated
+ IE: included elsewhere
+ C: confidantial information
+ NA: not applicable
+ NO: not occurring
"""

print("number of rows where the emissions and the notation are both missing -->",(emissions_df.emissions.isna() & emissions_df.Notation.isna()).sum())
print("number of rows where the emissions are missing and the notation is present -->",(emissions_df.emissions.isna() & emissions_df.Notation.notna()).sum())

"""The *Notation* column predominantly provides explanations for instances where emissions are marked as 'NA.' To enhance the efficiency of the data frame, we have decided to eliminate this column."""

print(emissions_df.DataSource.unique())
print(emissions_df.PublicationDate.unique())
print(emissions_df.Format_name.unique())
print(emissions_df.Unit.unique())

"""The columns we are interested in are only 5 out of 13.

We only need one of *Country* and *Country_Code*.

Also only one of *Sector*, *Sector_code*, *Parent_sector_code* is needed.

*Format_name*, *DataSource*, *PublicationDate* are the same for every row.

The unit is always Gigagram (1 million kg or 1000 tons) or Co2 equivalent of Gigagram, so we can drop that column as well
"""

chosen_columns = ["Country","Sector_name","Pollutant_name","Year","emissions"]

emissions_df = emissions_df.reindex(columns = chosen_columns)
emissions_df

emissions_df.Country.unique()

# We can remove the rows with countries that are not in EU-27:
# Iceland, Norway, Switzerland, Türkiye

mask = emissions_df.Country.isin(["Iceland","Norway","Switzerland","Türkiye"])
emissions_df = emissions_df[~mask]

# We will remove some sectors, since there are so many of them and we mostly want to look at overall emissions
print(emissions_df.Sector_name.unique().size)
np.sort(emissions_df.Sector_name.unique())

"""The main sectors are:


1.   Energy
2.   Industrial Processes and Product Use
3.   Agriculture
4.   Land Use, Land-Use Change and Forestry
5.   Waste management
6.   Other (most of this data is NA)


"""

# We will keep the following ones:

sectors_to_keep = '''
1 - Energy
1.A.1 - Energy Industries
1.A.2 - Manufacturing Industries and Construction
1.A.3 - Transport
1.A.4 - Other Sectors
1.A.5 - Other Other Sectors
1.AA - Fuel Combustion - Sectoral approach
1.B - Fugitive Emissions from Fuels
1.B.1 - Solid Fuels
1.B.2 - Oil and Natural Gas and Other Emissions from Energy Production
1.C - CO2 Transport and Storage
1.D.1 - International Bunkers
1.D.2 - Multilateral Operations
1.D.3 - CO2 emissions from biomass
2 - Industrial Processes and Product Use
2.A - Mineral Industry
2.B - Chemical Industry
2.C - Metal Industry
2.D - Non-energy Products from Fuels and Solvent Use
2.E - Electronics Industry
2.F - Product Uses as Substitutes for ODS
2.G - Other Product Manufacture and Use
2.H - Other Industrial Process and Product Use
3 - Agriculture
3.1 - Livestock
3.A - Enteric Fermentation
3.B - Manure Management
3.C - Rice Cultivation
3.D - Agricultural Soils
3.E - Prescribed Burning of Savannas
3.F - Field Burning of Agricultural Residues
3.G - Liming
3.H - Urea Application
3.I - Other Carbon-containing Fertilizers
3.J - Other agriculture emissions
4 - Land Use, Land-Use Change and Forestry
4.A - Forest Land
4.B - Cropland
4.C - Grassland
4.D - Wetlands
4.E - Settlements
4.F - Other Land
4.G - Harvested Wood Products
4.H - Other LULUCF
5 - Waste management
5.A - Solid Waste Disposal
5.B - Biological Treatment of Solid Waste
5.C - Incineration and Open Burning of Waste
5.D - Wastewater Treatment and Discharge
5.E - Other Disposal
6 - Other Sector
Total emissions (UNFCCC)
Total emissions with international aviation (EU 2020)
Total emissions with international transport (EEA)
Total net emissions (UNFCCC)
Total net emissions with international aviation (EU NDC)
Total net emissions with international transport (EEA)
ind_CO2 - Indirect CO2
'''

mask = emissions_df.Sector_name.isin(sectors_to_keep.split(sep = "\n")[1:-1])
emissions_df = emissions_df[mask]

print(emissions_df.Sector_name.unique().size)
np.sort(emissions_df.Sector_name.unique())

"""Now that the DataFrame is smaller and contains the relevant information for our analysis, we can start the exploration of the data. We plot the time series of emissions for all 27 EU countries as well as the total."""

# It becomes more useful to reindex the dataframe with pandas' Multiindex feature
df_emissions_multiindex = emissions_df.set_index(["Country","Pollutant_name", "Sector_name", "Year"]).sort_index()
df_emissions_multiindex.info()

"""We make one plot per country, with one line per sector. For now we only look at All GHGs as pollutant."""

countries = np.sort(emissions_df.Country.unique())
pollutant = "All greenhouse gases - (CO2 equivalent)" # I'm not yet looking at other Greenhouse Gases
chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']

def get_smaller_df(country, pollutant, sector):
    return df_emissions_multiindex.loc[country, pollutant, sector].copy()

plt.rc('figure', figsize = (7,5))

for country in countries:
    for sector in chosen_sectors:
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            plt.plot(df_to_plot.emissions/1000, label = sector, marker = "|")
            plt.title(country +"\n "+ pollutant + " millions of tons")
            plt.legend(bbox_to_anchor=(1, 1))
        except KeyError:
            print(country, pollutant, sector ," was not found")
    plt.show()

"""Now we plot the same data, but we make one plot per sector and compare some countries."""

countries = ['Italy', 'Ireland', 'Sweden', 'Germany', "Spain","France"]
chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']
pollutant = "All greenhouse gases - (CO2 equivalent)" # I'm not yet looking at other Greenhouse Gases

def get_smaller_df(country, pollutant, sector):
    return df_emissions_multiindex.loc[country, pollutant, sector].copy()

plt.rc('figure', figsize = (7,5))

for sector in chosen_sectors:
    for country in countries:
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            plt.plot(df_to_plot.emissions/1000,label = country, marker = "|")
        except KeyError:
            print(country, pollutant, sector, "gave a key error")
    plt.title(sector + "\n" + pollutant + "millions of tons")
    plt.legend(bbox_to_anchor=(1, 1))
    plt.show()

country = "EU-27"
chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']


def get_smaller_df(country, pollutant, sector):
    return df_emissions_multiindex.loc[country, pollutant, sector].copy()

plt.rc('figure', figsize = (7,5))

for sector in chosen_sectors:
    for pollutant in emissions_df.Pollutant_name.unique():
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            plt.plot(df_to_plot.emissions/1000,label = pollutant, marker = '|')
        except KeyError:
            print(country, pollutant, sector, "gave a key error")
    plt.title(sector + "\n" + country + "millions of tons")
    plt.legend(bbox_to_anchor=(1, 1))
    plt.show()

emissions_df.Pollutant_name.value_counts()

"""### Population Dataset

Firstly, we decide to derive our own data regarding population through the OECD database.
"""

urllib.request.urlretrieve("https://stats.oecd.org/sdmx-json/data/DP_LIVE/AUT+BEL+BGR+CYP+CZE+DEU+DNK+ESP+EST+EU27+FIN+FRA+GRC+HRV+HUN+IRL+ITA+LTU+LUX+LVA+MLT+NLD+OECD+POL+PRT+ROU+SVK+SVN+SWE.POP.TOT.MLN_PER.A/OECD?contentType=csv&detail=code&separator=comma&csv-lang=en&startPeriod=1990&endPeriod=2022", "GLEMfolder/population.csv")
Data_Pop = pd.read_csv("GLEMfolder/population.csv")

# Through the use of drop I went to select only the data that we needed
# first, I excluded from LOCATION: the OECD data that we were not interested in
# then I proceeded with the SUBJECT column by selecting only the TOTs and excluding therefore
# MEN and WOMEN

Data_Pop.drop(Data_Pop[(Data_Pop['SUBJECT'] != 'TOT')].index, inplace = True)
Data_Pop.drop(Data_Pop[(Data_Pop['LOCATION'] == 'OECD')].index, inplace = True)

# Then I eliminated the columns that have uninteresting values
delete = ["INDICATOR","FREQUENCY", "Flag Codes", 'MEASURE', 'SUBJECT']
Data_Pop.drop(columns = delete, inplace = True)

# I've replaced the name of the column and the index to make the dataset more understandable
Data_Pop = Data_Pop.replace('MLN_PER','MLN')

INDEX = [x for x in range(len(Data_Pop["LOCATION"]))]
Data_Pop['INDEX'] = INDEX

Data_Pop = Data_Pop.set_index('INDEX')

# Final Result
Data_Pop

# I verified that all countries were present and that everything was correct
Data_Pop['LOCATION'].unique()

"""## I.II. Merging the Emissions DataFrame with the Population DataFrame"""

countries = np.sort(emissions_df.Country.unique())
countries

np.sort(Data_Pop.LOCATION.unique())

"""This is the main issue we have to solve: change from a 3 letter string to the full country name"""

codes = ["AUT",'BEL','BGR',"HRV",'CYP',"CZE",'DNK','EU27','EST','FIN','FRA','DEU','GRC','HUN','IRL','ITA','LVA','LTU','LUX','MLT','NLD','POL','PRT','ROU','SVK','SVN','ESP','SWE']
countries_map = {code : country for code, country in zip(codes,countries,)}
countries_map

Data_Pop["Country"] = Data_Pop.LOCATION.map(countries_map)
del Data_Pop["LOCATION"]
# We created a new column that has the same format as the emissions data frame and we deleted the previous one
Data_Pop

# Now we have to change the names of the two other columns
Data_Pop.rename(columns={"TIME": "Year", "Value": "pop_mil"}, inplace= True)
Data_Pop

emissions_df = emissions_df.merge(Data_Pop, on=("Country","Year"))

# Having merged the two datasets with population and emissions, we can calculate per capita emissions
emissions_df["per_capita_emission"] = emissions_df["emissions"]/(emissions_df["pop_mil"]*1000000)

# Note: the population is in millions, so we multiply the denominator by 1 million
# This way the unit of measure is Gigagram per person

# again we use the multiindex feature
df_emissions_multiindex = emissions_df.set_index(["Country","Pollutant_name", "Sector_name", "Year"]).sort_index()

"""First we look at one country per plot, with 7 different sectors and pollutant = all GHGs."""

countries = np.sort(emissions_df.Country.unique())
pollutant = "All greenhouse gases - (CO2 equivalent)" # I'm not yet looking at other Greenhouse Gases
chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']

def get_smaller_df(country, pollutant, sector):
    return df_emissions_multiindex.loc[country, pollutant, sector].copy()

plt.rc('figure', figsize = (7,5))

for country in countries:
    for sector in chosen_sectors:
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            plt.plot(df_to_plot.per_capita_emission*1000, label = sector, marker = '|')
            plt.title(country +"\n "+ pollutant + " tons per capita")
            plt.legend(bbox_to_anchor=(1, 1))
        except KeyError:
            print(country, pollutant, sector ," was not found")

    plt.show()

"""Now we plot all countries together, one plot per sector. Again the pollutant is All GHGs."""

countries = np.sort(emissions_df.Country.unique())
pollutant = "All greenhouse gases - (CO2 equivalent)" # I'm not yet looking at other Greenhouse Gases
chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']

def get_smaller_df(country, pollutant, sector):
    return df_emissions_multiindex.loc[country, pollutant, sector].copy()

plt.rc('figure', figsize = (7,5))

for sector in chosen_sectors:
    for country in countries:
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            plt.plot(df_to_plot.per_capita_emission*1000, label = country, marker = '|')
        except KeyError:
            print(country, pollutant, sector ," was not found")


    plt.title(sector + "\n"+  pollutant + " tons per capita")
    plt.legend(bbox_to_anchor=(1, 1))

    plt.show()

"""The previous plots are too confusing with 28 countries all together; for this reason we select only a few of them."""

countries = ['Italy', 'Ireland', 'Sweden', 'Germany', "Spain","France"]
pollutant = "All greenhouse gases - (CO2 equivalent)" # I'm not yet looking at other Greenhouse Gases
chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']

def get_smaller_df(country, pollutant, sector):
    return df_emissions_multiindex.loc[country, pollutant, sector].copy()

plt.rc('figure', figsize = (7,5))

for sector in chosen_sectors:
    for country in countries:
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            plt.plot(df_to_plot.per_capita_emission*1000, label = country, marker = '|')
        except KeyError:
            print(country, pollutant, sector ," was not found")


    plt.title(sector + "\n"+  pollutant + " tons per capita")
    plt.legend(bbox_to_anchor=(1, 1))

    plt.show()

# HFCs
pollutant = "HFCs - (CO2 equivalent)"
sector = "2 - Industrial Processes and Product Use"

plt.rc('figure', figsize = (7,5))

for country in ['Italy', 'Ireland', 'Sweden', 'Germany', "Spain","France","EU-27"]:
    (emissions_df.set_index(["Pollutant_name", "Sector_name","Country", "Year"]).sort_index().loc[pollutant].loc[sector].loc[country].per_capita_emission*1000).plot(label = country, marker = '|')
    plt.legend()
    plt.title(pollutant + " Tons per capita" + "\n" + sector)
plt.show()

"""## I.III. Choropleth Maps

Two new packages are used to create the map: **geopandas** and **plotly.express**. First, we create a dictionary that also had *Country Codes* so that once implemented in the DataFrame the new packages used can perform best and use specific features such as "locations."
"""

dic = {'Austria' : 'AUT',
       'Belgium' : 'BEL',
       'Bulgaria' : 'BGR',
       'Cyprus' : 'CYP',
       'Czechia' : 'CZE',
       'Germany' : 'DEU',
       'Denmark' : 'DNK',
       'Estonia' : 'EST',
       'Spain' : 'ESP',
       'Finland' : 'FIN',
       'France' : 'FRA',
       'Greece' : 'GRC',
       'Croatia' : 'HRV',
       'Hungary' : 'HUN',
       'Ireland' : 'IRL',
       'Italy' : 'ITA',
       'Lithuania' : 'LTU',
       'Luxembourg' : 'LUX',
       'Latvia' : 'LVA',
       'Malta' : 'MLT',
       'Netherlands' : 'NLD',
       'Poland' : 'POL',
       'Portugal' : 'PRT',
       'Romania' : 'ROU',
       'Sweden' : 'SWE',
       'Slovenia' : 'SVN',
       'Slovakia' : 'SVK'}

mask1 = emissions_df["Sector_name"] == "Total net emissions (UNFCCC)"
mask2 = emissions_df["Pollutant_name"] != 'NF3 - (CO2 equivalent)' # --> Deleted because NaN
mask3 = emissions_df["Pollutant_name"] != 'Unspecified mix of HFCs and PFCs - (CO2 equivalent)' # --> Deleted because NaN

df_maps = emissions_df[mask1]
df_maps = df_maps[mask2]
df_maps = df_maps[mask3]

df_maps.drop(df_maps[(df_maps['Country'] == 'EU-27')].index, inplace = True)

df_maps['Country_code'] = df_maps["Country"].map(dic)

df_maps = df_maps.sort_values("Year")
df_maps.per_capita_emission.min()

for pollutant in df_maps.Pollutant_name.unique():
    pollutant_data = df_maps[df_maps.Pollutant_name == pollutant]
    pollutant_data['per_capita_emission'] = pollutant_data['per_capita_emission'] * 1000 # unit is tons per capita

    min = pollutant_data['per_capita_emission'].min()
    max = pollutant_data['per_capita_emission'].max()

    fig = px.choropleth(pollutant_data,
                        locations = "Country_code",
                        range_color = (min, max),
                        color  ="per_capita_emission",
                        color_continuous_scale = "Emrld",
                        scope = "europe",
                        animation_frame = "Year")

    fig.update_geos(fitbounds="locations", visible=True)
    fig.update_layout(title_text = f'{pollutant}', margin={"r":10,"t":10,"l":10,"b":10})
    fig.show()

    fig.write_html(str(pollutant) + '.html')

# if you want to change color "https://plotly.com/python/builtin-colorscales/"

"""We encounter the following error: *A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead*. Even if this error occur, we know that we are using a copy instead of the real DataFrame as we don't want to modify the original one.

We are aware of the fact that this error occur in the following Chapters too.

## I.IV. Key Points from a First Look at Emissions Levels

The plots of sectors for each Country show a general trend in annual emissions: the emissions from Energy production dictate the path followed by *Total Emissions* and *Total Net Emissions*.

Focusing our attention to the trajectory of *All Green House Gasses*, we can affirm that trend is determined mainly by the path followed by *CO2* gas.

Comparing Total Emissions between countries is difficult because of different populations. In order to avoid this issue we calculated per capita emission.

# II° Chapter

In this subsection, you will find a detailed account of the data cleaning operations conducted on a set of a CSV file. The file contains information about the **Gross Domestic Products (GDPs)** of all 27 countries of the European Union, categorized according to the sectors in the classification system employed for GDP computation. These sectors are: *Agriculture, forestry and fishing*, *Construction*, *Distributive trade, repairs; transport; accommod., food serv.*, *Financial and insurance activities*, *Information and communication*, *Other service activities*, *Prof., scientific, techn.; admin., support serv. activities*, *Public admin.; compulsory s.s.; education; human health*, *Real estate activities*. Within the dataset, a cumulative entry is included, summing the values from all sectors for a comprehensive overview.

## II.I. GDPs analysis: estracting data from Eurostat dataset

The following DataFrame contains data regarding the Gross Domestic Products (GDPs) of individual EU member countries, expressed in millions of euros.
"""

# downloading the dataset
urllib.request.urlretrieve("https://ec.europa.eu/eurostat/api/dissemination/sdmx/2.1/data/nama_10_gdp/A.CP_MEUR.B1GQ.EU27_2020+EU28+EU15+EA+EA20+EA19+EA12+BE+BG+CZ+DK+DE+EE+IE+EL+ES+FR+HR+IT+CY+LV+LT+LU+HU+MT+NL+AT+PL+PT+RO+SI+SK+FI+SE+IS+LI+NO+CH+UK+BA+ME+MK+AL+RS+TR+XK/?format=SDMX-CSV&startPeriod=1990&endPeriod=2022", "GLEMfolder/df_Eurostat")
df_Eurostat = pd.read_csv("./GLEMfolder/df_Eurostat")
df_Eurostat

"""Since in the dataset there is not a column with the full country names, we need to add it stating from the country code."""

# We found a list containing country name - code
Country_code = [['European Union - 27 countries (from 2020)','EU27_2020'],
    ['European Union - 28 countries (2013-2020)','EU28'],
    ['European Union - 15 countries (1995-2004)' ,'EU15'],
    ['Euro area (EA11-1999, EA12-2001, EA13-2007, EA15-2008, EA16-2009, EA17-2011, EA18-2014, EA19-2015, EA20-2023)','EA'],
    ['Euro area - 20 countries (from 2023)','EA20'],
    ['Euro area - 19 countries  (2015-2022)','EA19'],
    ["Euro area - 12 countries(2001-2006)",'EA12'],
    ['Belgium','BE'],
    ['Bulgaria', 'BG'],
    ['Czechia','CZ'],
    ['Denmark','DK'],
    ['Germany','DE'],
    ['Estonia','EE'],
    ['Ireland','IE'],
    ['Greece','EL'],
    ['Spain','ES'],
    ['France','FR'],
    ['Croatia','HR'],
    ['Italy','IT'],
    ['Cyprus','CY'],
    ['Latvia','LV'],
    ['Lithuania','LT'],
    ['Luxembourg','LU'],
    ['Hungary','HU'],
    ['Malta','MT'],
    ['Netherlands','NL'],
    ['Austria','AT'],
    ['Poland','PL'],
    ['Portugal','PT'],
    ['Romania','RO'],
    ['Slovenia','SI'],
    ['Slovakia','SK'],
    ['Finland','FI'],
    ['Sweden','SE'],
    ['Iceland','IS'],
    ['Liechtenstein','LI'],
    ['Norway','NO'],
    ['Switzerland','CH'],
    ['United Kingdom','UK'],
    ['Bosnia and Herzegovina', 'BA'],
    ['Montenegro','ME'],
    ['North Macedonia','MK'] ,
    ['Albania','AL'],
    ['Serbia','RS'],
    ['Türkiye','TR'],
    ['Kosovo','XK']]

# creation of a dictionary for the conversion
Code_to_country = {}
for el in Country_code:
    Code_to_country[el[1]] = el[0]

df_Eurostat['Country'] = df_Eurostat['geo'].map(Code_to_country)
df_Eurostat

# cleaning and ordering data
df_Eurostat = df_Eurostat.drop(columns = ['OBS_FLAG', 'na_item', 'LAST UPDATE', 'DATAFLOW'])
df_Eurostat = df_Eurostat.reindex(['geo', 'Country', 'TIME_PERIOD', 'OBS_VALUE', 'unit', 'freq'] , axis=1)

# dropping some data
mask = df_Eurostat['Country'].isin(['European Union - 28 countries (2013-2020)',
                         'European Union - 15 countries (1995-2004)',
                         'Euro area (EA11-1999, EA12-2001, EA13-2007, EA15-2008, EA16-2009, EA17-2011, EA18-2014, EA19-2015, EA20-2023)',
                         'Euro area - 20 countries (from 2023)',
                         'Euro area - 19 countries  (2015-2022)',
                         "Euro area - 12 countries(2001-2006)",
                        "Iceland", 'Liechtenstein', 'Norway', 'Switzerland','United Kingdom','Bosnia and Herzegovina',
                          'Montenegro','North Macedonia','Albania','Serbia','Türkiye','Kosovo'])
df_Eurostat = df_Eurostat[~mask]
df_Eurostat = df_Eurostat.reset_index(drop = True)

# rewriting the country code in a 3 lecter format with the previous conversion dictionary
df_Eurostat['geo'] = df_Eurostat['Country'].map(dic)
df_Eurostat

# plotting a distribution of the GDP from the euro adoption (2002 - Italy)
mask = df_Eurostat['TIME_PERIOD'].isin(range(2002,2023))
df_to_plot = df_Eurostat[mask]

fig = px.choropleth(df_to_plot.sort_values('TIME_PERIOD'),
                    locations = "geo",
                    range_color = (0, 3000000),
                    color  ="OBS_VALUE",
                    color_continuous_scale = "Hot",
                    scope = "europe",
                    animation_frame = "TIME_PERIOD")

fig.update_geos(fitbounds="locations", visible=False)
fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
fig.show()

"""To compute some operations, we created a new DataFrame that includes observed values and excludes countries not belonging to the EU."""

GDP_Euro = df_Eurostat.pivot(index = "TIME_PERIOD" , columns = "Country" , values = "OBS_VALUE")
GDP_Euro.index.name = "Year"
GDP_Euro.rename(columns = {"European Union - 27 countries (from 2020)":"EU-27"},inplace = True)
GDP_Euro

"""### GDPs Evolution: Annual Growth Representation"""

# creation of a GDPs' growth rate dataset
GDP_Var = GDP_Euro.copy()
GDP_Var = GDP_Var.pct_change()
GDP_Var = GDP_Var.loc[2002:2022]
GDP_Var

fig, ax = plt.subplots(1, figsize = (7,5))
for el in GDP_Var:
    plt.plot(GDP_Var[el], label=el, marker = '|')
    plt.legend(title='Country', loc='upper center', bbox_to_anchor=(0.5, -0.2), ncol = 4, fontsize = "small")
    plt.xlabel('Year')
    plt.ylabel('Growth of GDP')
    plt.ylim(-0.3, 0.4)
    x_lab = GDP_Var.index
    ticks = ax.set_xticks(x_lab)
plt.xticks(range(2002, 2023, 4), rotation=35)
plt.show()

fig, ax = plt.subplots(1, figsize = (7,5))
for el in ['EU-27', 'Italy', 'Ireland', 'Sweden', 'Germany',"France", "Spain"]:
    plt.plot(GDP_Var[el], label=el, marker = '|')
    plt.legend(title='Country', loc='upper left', bbox_to_anchor=(1, 1), fontsize = 'small')
    plt.xlabel('Year')
    plt.ylabel('Growt of GDP')
    plt.ylim(-0.15, 0.4)
    # x_lab = GDP_Var.index
    # ticks = ax.set_xticks(x_lab)
    # labels = ax.set_xticklabels(x_lab, rotation=30, fontsize='small')
plt.xticks(range(2002, 2023, 4), rotation=35)
plt.show()

"""## II.II. GDPs analysis: estracting data from OECD dataset

The following DataFrame contains data regarding the *Gross Domestic Products (output approach)* of individual EU member countries, expressed in millions of euros for those countries which adopt it. All the others express their GDP in their currency.

Initially, we cleanse the original dataset to retain only the pertinent information.

We use the pandasdmx library to take data directly from OECD.
"""

# Tell pdmx we want OECD data
oecd = pdmx.Request("OECD")

# Set out everything about the request in the format specified by the OECD API
data = oecd.data(
    resource_id="SNA_TABLE1",
    key="AUT+BEL+CZE+DNK+EST+FIN+FRA+DEU+GRC+HUN+IRL+ITA+LVA+LTU+LUX+NLD+POL+PRT+SVK+SVN+ESP+SWE+EU27_2020+BGR+HRV+CYP+MLT+ROU.B1_GA+B1GVA+B1GVB_E+B1GVF+B1GVG_I+B1GVJ+B1GVK+B1GVL+B1GVM_N+B1GVO_Q+B1GVR_U.C/all?startTime=1990&endTime=2022",
).to_pandas()

df_OECD = pd.DataFrame(data).reset_index()

#converting the transaction code to a transaction name
trans_code_to_name = {'B1_GA': 'Gross domestic product', 'B1GVA': 'Agriculture, forestry and fishing', 'B1GVB_E': 'Industry, including energy', 'B1GVF': 'Construction', 'B1GVG_I': 'Distributive trade, repairs; transport; accommod., food serv.', 'B1GVJ': 'Information and communication', 'B1GVK': 'Financial and insurance activities', 'B1GVL': 'Real estate activities', 'B1GVM_N': 'Prof., scientific, techn.; admin., support serv. activities', 'B1GVO_Q': 'Public admin.; compulsory s.s.; education; human health', 'B1GVR_U': 'Other service activities'}
df_OECD['Sectors'] = df_OECD['TRANSACT'].map(trans_code_to_name)


Country_code_to_name = {'AUT': 'Austria', 'BEL': 'Belgium', 'BGR': 'Bulgaria', 'HRV': 'Croatia', 'CYP': 'Cyprus', 'CZE': 'Czechia', 'DNK': 'Denmark', 'EU27_2020': 'EU-27', 'EST': 'Estonia', 'FIN': 'Finland', 'FRA': 'France', 'DEU': 'Germany', 'GRC': 'Greece', 'HUN': 'Hungary', 'IRL': 'Ireland', 'ITA': 'Italy', 'LVA': 'Latvia', 'LTU': 'Lithuania', 'LUX': 'Luxembourg', 'MLT': 'Malta', 'NLD': 'Netherlands', 'POL': 'Poland', 'PRT': 'Portugal', 'ROU': 'Romania', 'SVK': 'Slovakia', 'SVN': 'Slovenia', 'ESP': 'Spain', 'SWE': 'Sweden'}
df_OECD['Country'] = df_OECD['LOCATION'].map(Country_code_to_name)

# cleaning and ordering data
df_OECD = df_OECD.drop(columns = ['MEASURE', 'TRANSACT', 'LOCATION'])
df_OECD = df_OECD.reindex(['Country', 'Sectors', 'TIME_PERIOD', 'value'] , axis=1)
df_OECD = df_OECD.rename(columns = {"TIME_PERIOD" : "Year" , "value" : "Value"})

# converting data type
df_OECD['Year'] = df_OECD.Year.astype('int32')

df_OECD

"""### GDPs analysis: Before and after the adoption of the Euro.

Subsequently, we group the data based on three shared variables for each country, namely *Country*, *Sectors* and *Year*. This grouping facilitates a comprehensive overview of our final dataset.
"""

# setting columns and saving the df before the EURO adoption
df_OECD_beuro = df_OECD.pivot(index = ["Country", "Year"] , columns = ["Sectors"], values = "Value")

df_OECD_beuro

"""### GDPs analysis: since the adoption of the Euro to the present day.

We want now to focus our attention to the growth of the GDP per sector since the adoption of Euro (in Italy - 2002) to the present day (last availabe year: 2022).
"""

# filtering years from 2002 to 2022
indx = [i for i in range(2002 , 2022)]

mask = df_OECD['Year'].isin(indx)

df_OECD_aeuro = df_OECD[mask]
df_OECD_aeuro

#  setting columns and saving the df before the EURO adoption
df_OECD_aeuro = df_OECD_aeuro.pivot(index = ["Country", "Year"] , columns = ["Sectors"] , values = "Value")

df_OECD_aeuro

"""
As we have already mentioned, each country expresses the values of GDP in its own currency. For this reason, we standardized the values by computing indices based on 100, using the total GDP as a reference."""

# creating a copy of the previous dataframe
Percent_GDP = df_OECD_aeuro.copy()

# converting from currency to percents
for el in Percent_GDP:
  for i1, i2 in Percent_GDP[el].index:
    Percent_GDP[el][i1][i2] = (Percent_GDP[el][i1][i2])/(df_OECD_aeuro["Gross domestic product"][i1][i2])
Percent_GDP = Percent_GDP.applymap(lambda x: x * 100 if pd.notna(x) else x)
Percent_GDP

"""## II.III. GDP per Sector's Plots

In the following visualization, we can discern the sector that has mostly contributed to the GDP for each country.
"""

# Get unique country names
countries = Percent_GDP.index.get_level_values('Country').unique()

# Create the subplots grid
fig, axes = plt.subplots(int(np.ceil(len(countries)/7)), 7, figsize=(5*int(np.ceil(len(countries)/4)), 20))

# Flatten the 2D array of subplots into a 1D array
axes = axes.flatten()

# Plotting for each country
for i, country in enumerate(countries):
    country_data = Percent_GDP.loc[Percent_GDP.index.get_level_values('Country') == country]
    ax = axes[i]

    country_data.plot(kind='line', ax=ax, marker='|', colormap="tab20")
    ax.set_title(f'GDP Percentage by Sector in {country}')
    ax.set_xlabel('Year')
    ax.set_ylabel('Percentage of GDP')
    ax.legend().set_visible(False)  # Hide individual legends
    x_lab = GDP_Var.index
    ax.set_xticks(range(len(x_lab)))
    labels = ax.set_xticklabels(x_lab, rotation=30, fontsize='small')
    ax.set_ylim(0, 30)

# Add a single legend outside the subplots grid
handles, labels = axes[-1].get_legend_handles_labels()
fig.legend(handles, labels, title='Sector', loc='upper left', bbox_to_anchor=(1, 1), fontsize='small')

# Adjust layout to prevent overlapping
plt.tight_layout()
plt.show()

"""We want to focus our attention on Italy and on the European Union in general; to do that we plot again the single graphics for both of them. This approach aims to avoid confusion among the 28 plots presented earlier."""

# Italy's GDP plot
Italy_data = Percent_GDP.loc[Percent_GDP.index.get_level_values('Country') == "Italy"]
fig, ax = plt.subplots(figsize = (8,4))
Italy_data.plot(kind='line', ax = ax, marker='|', colormap = "tab20")
plt.title('GDP Percentage by Sector in Italy')
plt.xlabel('Year')
plt.ylabel('Percentage of GDP')
plt.legend(title='Sector', loc='upper left', bbox_to_anchor=(1, 1), fontsize = 'small')
ax.set_xticks(range(len(x_lab)))
labels = ax.set_xticklabels(x_lab, rotation=30, fontsize='small')
plt.ylim(0, 25)
plt.show()

# EU-27's GDP plot
EU27_data = Percent_GDP.loc[Percent_GDP.index.get_level_values('Country') == 'EU-27']
fig, ax = plt.subplots(figsize = (8,4))
EU27_data.plot(kind='line', ax = ax, marker='|', colormap = "tab20")
plt.title('GDP Percentage by Sector in EU-27')
plt.xlabel('Year')
plt.ylabel('Percentage of GDP')
plt.legend(title='Sector', loc='upper left', bbox_to_anchor=(1, 1), fontsize = 'small')
ax.set_xticks(range(len(x_lab)))
labels = ax.set_xticklabels(x_lab, rotation=30, fontsize='small')
plt.ylim(0, 20)
plt.show()

"""Looking at the plot for Italy, it becomes evident that the "*Industry, including energy*" and "*Distributive trade, repairs; transport; accommod., food serv.*" are the leading sector in the country. For this reason, we may want to see in which other countries the  "*Industry, including energy*" and "*Distributive trade, repairs; transport; accommod., food serv.*" are the leading sector over years. To achieve this, we extract the relevant data from the DataFrame, sort it, and lastly obtain an ordered list featuring the names of countries where this sectors hold a leading position."""

# Computing a list of countries in ascending order by "Industry, including energy"/"Gross domestic product" mean
industry_percentages = Percent_GDP.groupby("Country")["Industry, including energy"].mean() / Percent_GDP.groupby("Country")["Gross domestic product"].mean()
sorted_countries_i = list(industry_percentages.sort_values(ascending=True).index)

# Computing a list of countries in ascending order by "Distributive trade, repairs; transport; accommod., food serv."/"Gross domestic product" mean
tourism_percentages = Percent_GDP.groupby("Country")["Distributive trade, repairs; transport; accommod., food serv."].mean() / Percent_GDP.groupby("Country")["Gross domestic product"].mean()
sorted_countries_t = list(tourism_percentages.sort_values(ascending=True).index)

# Plotting
fig, ax = plt.subplots(figsize=(12, 8))
bar_height = 0.4
ind = np.arange(len(sorted_countries_i))
ax.barh(ind, industry_percentages[sorted_countries_i], height=bar_height, color='brown', label='Industry, including energy')
ax.barh(ind + bar_height, tourism_percentages[sorted_countries_t], height=bar_height, color='green', label='Distributive trade, repairs; transport; accommod., food serv.')
plt.ylabel('Percentage of GDP')
plt.title('"Industry, including energy" and "Distributive trade, repairs; transport; accommod., food serv." Percentage of GDP by Country')
plt.legend(frameon=False)
plt.yticks(ind + bar_height / 2, sorted_countries_i)
plt.show()

fig.savefig("GDP_industry_tourism_stacked.svg", facecolor=(1, 1, 1, 0), transparent=True, bbox_inches='tight')

"""## II.IV. Convergence of GDP and GHG: A Merging Dataset

We now aim to integrate the GHG dataset discussed in Chapter I with the previously examined GDP in Euro dataset.

Firstly, we compute the Annual Growth Variation for the GHG too, just as was done previously for the GDPs. By doing this, we can create a merged DataFrame that includes total values, per capita values, and annual variations for both variables (GHG and GDP). Our focus is on Italy and European Union in general.
"""

# Merging emissions_df and gdp
chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']

emissions_small = df_emissions_multiindex.swaplevel("Country","Pollutant_name").loc["All greenhouse gases - (CO2 equivalent)"].swaplevel("Country","Sector_name").loc[chosen_sectors]

emissions_small
# This data frame only has 1 pollutant: All greenhouse gases
# There are only the main sectors 1-5 plus total and net emissions

emissions_small["per_capita_emiss_variation"] = emissions_small.per_capita_emission.pct_change()
# we add a column that has the percentage variation in emissions from the previous year

# We need to set each row that has year = 1990 to NA
emissions_small.reset_index(inplace = True)
emissions_small.set_index("Year", inplace = True)
emissions_small.loc[1990,"per_capita_emiss_variation"] = np.nan

# After setting the pct variation for 1990 to NA we go back to the original multiindex
emissions_small.reset_index(inplace = True)
emissions_small.set_index(["Sector_name","Country","Year"], inplace = True)
emissions_small

# recalling the GDP in Euro datset that will be used
GDP_Euro

# creating a pass-by dataframe to merge with the one above
gdp_tomerge = DataFrame(GDP_Euro.stack().swaplevel().sort_index())

gdp_tomerge.rename(columns = {0:"GDP"},inplace = True)

# merge
emissions_gdp_var = emissions_small.merge(gdp_tomerge, left_index = True, right_index = True)
emissions_gdp_var

emissions_gdp_var = emissions_gdp_var.swaplevel("Sector_name", "Year").copy()
emissions_gdp_var.sort_index(inplace = True)

# computing per_capita_GDP
emissions_gdp_var["per_capita_GDP"] = emissions_gdp_var["GDP"]/(emissions_gdp_var["pop_mil"]*1000000)

# computing the variation percentage
emissions_gdp_var["per_capita_GDP_var"] = emissions_gdp_var["per_capita_GDP"].pct_change()

# removing years before 1996 because pct_change calculates the variation with the wrong row
emissions_gdp_var.reset_index(inplace = True)
emissions_gdp_var.set_index("Year", inplace = True)
emissions_gdp_var.sort_index(inplace = True)
emissions_gdp_var = emissions_gdp_var.loc[1996:]
emissions_gdp_var.reset_index(inplace = True)
emissions_gdp_var.set_index(["Sector_name","Country","Year"], inplace = True)
emissions_gdp_var.sort_index(inplace = True)

emissions_gdp_var

emissions_gdp_var.info()

"""We proceed to select only Italy and total net emissions.

Then we repeat the same process for the European Union in general.
"""

merge_df_italy = emissions_gdp_var.swaplevel(0,1).loc["Italy"]
merge_df_italy = merge_df_italy.loc["Total net emissions (UNFCCC)"]
# merge_df_italy = merge_df_italy.loc[2002:]
merge_df_italy

merge_df_eu = emissions_gdp_var.swaplevel(0,1).loc["EU-27"]
merge_df_eu = merge_df_eu.loc["Total net emissions (UNFCCC)"]
# merge_df_eu = merge_df_eu.loc[2002:]
merge_df_eu

"""Lastly, we plot the datasets to provide a more comprehensive overview."""

# defining colors
colors = (merge_df_italy.emissions - np.min(merge_df_italy.emissions))/np.max(merge_df_italy.emissions)
colors = plt.get_cmap('Greens_r')(colors)

# Italy merged dataset plot
ax = merge_df_italy.plot.scatter(y = 'per_capita_emiss_variation', x = 'per_capita_GDP_var', title = "Italy", figsize = (7,5), s = 20, c = colors)

ax.plot([merge_df_italy['per_capita_GDP_var'].min(), merge_df_italy['per_capita_GDP_var'].max()],
        [merge_df_italy['per_capita_emiss_variation'].min(), merge_df_italy['per_capita_emiss_variation'].max()],
        color='blue', linestyle='--')

ax.set_ylabel("ΔGHG per capita")
ax.set_xlabel("ΔGDP per capita")

for i, row in merge_df_italy.iterrows():
    ax.text(row['per_capita_GDP_var'],row['per_capita_emiss_variation'], f'{i}', ha='left', fontsize = 8)
plt.show()

# defining colors
colors = (merge_df_italy.emissions - np.min(merge_df_italy.emissions))/np.max(merge_df_italy.emissions)
colors = plt.get_cmap('Greens_r')(colors)

# EU-27 merged dataset plot
ax = merge_df_eu.plot.scatter(y = 'per_capita_emiss_variation', x = 'per_capita_GDP_var', title = "EU-27", figsize = (7,5), s = 20, c = colors)

ax.plot([merge_df_eu['per_capita_GDP_var'].min(), merge_df_eu['per_capita_GDP_var'].max()],
        [merge_df_eu['per_capita_emiss_variation'].min(), merge_df_eu['per_capita_emiss_variation'].max()],
        color='blue', linestyle='--')

ax.set_ylabel("ΔGHG per capita")
ax.set_xlabel("ΔGDP per capita")

for i, row in merge_df_eu.iterrows():
    ax.text(row['per_capita_GDP_var'],row['per_capita_emiss_variation'], f'{i}', ha='left', fontsize = 8)

plt.get_cmap("Greens_r") # lighter points mean higher emissions

"""By looking to both of the scatterplots, it becomes evident that there is a correlation between the variations of GHG per capita and GDP per capita. Consequently, we might want to calculate the correlation coefficient between these two variables."""

# correlation
italy_corr = merge_df_italy['per_capita_GDP_var'].corr(merge_df_italy['per_capita_emiss_variation'])
print("Italy_corr:", italy_corr)

eu27_corr = merge_df_eu['per_capita_GDP_var'].corr(merge_df_eu['per_capita_emiss_variation'])
print("EU-27_corr:", eu27_corr)

# We try to remove the two oultiers 2020 and 2021
print(" italy: ",merge_df_italy.iloc[:-2]['per_capita_GDP_var'].corr(merge_df_italy.iloc[:-2]['per_capita_emiss_variation']))
print(" eu-27: ",merge_df_eu.iloc[:-2]['per_capita_GDP_var'].corr(merge_df_eu.iloc[:-2]['per_capita_emiss_variation']))

"""The correlation between per capita gdp growth and percapita emissions variation is significantly lower for total EU-27 if we exclude the outliers of the COVID-19 pandemic."""

# covariance
italy_cov = merge_df_italy['per_capita_GDP_var'].cov(merge_df_italy['per_capita_emiss_variation'])
print("Italy_cov:", italy_cov)

eu27_cov = merge_df_eu['per_capita_GDP_var'].cov(merge_df_eu['per_capita_emiss_variation'])
print("EU-27_corr:", eu27_cov)

"""Once computed the correlation coefficients of the two variables aforementioned for Italy and EU-27, it can be confirmed that indeed a relatively high correlation between the two. By computing the covariance we can affirm that the relationship between the two variables is positive.

# III° Chapter


In this third section, our aim was to identify the sector with the highest Greenhouse Gas Emissions and assess its impact on the total GDP of each European Union country. To achieve this, we recall the previous merged dataset *emissions_gdp_var*.
"""

emissions_gdp_var

"""## III.I. ΔGHG per capita vs. ΔGDP per capita: Analysis for Each Emissions' Sectors

In our analysis, we try to understand the correlation between the variations of both GHG and GDP for each sector identified in the emissions' dataset.
"""

# computing the correlation between "per_capita_emiss_variation" and "per_capita_GDP_var" for each sector
sectors_corr = emissions_gdp_var.reset_index().groupby("Sector_name").apply(lambda x: x[["per_capita_emiss_variation", "per_capita_GDP_var"]].corr().iloc[1,0])

# creating a scatterplot for each sector
palette = sns.color_palette("viridis", n_colors=len(emissions_gdp_var.index.get_level_values('Country').unique()))

chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']

for sector in chosen_sectors:
  fig, ax = plt.subplots(figsize=(7, 5))
  ax.set_title(sector)

  for i, country in enumerate(emissions_gdp_var.index.get_level_values('Country').unique()):
      country_data = emissions_gdp_var.loc[sector].loc[country]
      ax.scatter(x=country_data['per_capita_GDP_var'], y=country_data['per_capita_emiss_variation'], label=country, color= palette[i], s=5)

  ax.legend(title='Country', loc='upper center', bbox_to_anchor=(0.5, -0.2), ncol=7, fontsize=8)
  plt.ylim(-0.2,0.2)
  ax.set_ylabel("ΔGHG per capita")
  ax.set_xlabel("ΔGDP per capita")
  ax.text(x = -0.3, y = 0.175, s = f"corr. = {sectors_corr[sector]:.2f}", c = "black")
  plt.show()

"""While plotting the previous scatterplots, we are looking at the relationship between the variation of GDP and GHG both. It is evident that an increase in GDP variation corresponds to an increase in GHG variation.

Specifically, in Chapter I, our observations highlighted that the primary sector influencing the trajectory of total emissions is the *Energy* sector. This is underlined by the high correlation, mirroring the correlation observed in *Total emissions*.

Otherwise as expected, the *Total net emissions*' correlation is tending to zero. This is determined by the fact that in some countries, the relationship between the variations per capita of both GDP and GHG is not that strong.

While the value of the *Land Use, Land-Use Change and Forestry*'s correlation is negative, but at the same time is tending to zero. For this reason, we can say that there's no correlation between a growth in variations of GDP and GHG both.

## III.II. ΔGHG per capita vs. ΔGDP per capita: total net emissions

As we've already mentioned, the *ΔTotal net emissions'* correlation with the *ΔGDP* is tending to zero. For this reason, we want to understand which is the correlation between the two variables in each country.
"""

sector = "Total net emissions (UNFCCC)"
countries = ['EU-27', "France", 'Germany', 'Italy', 'Ireland', 'Sweden',  "Spain"]

# computing the correlation between "per_capita_emiss_variation" and "per_capita_GDP_var" for the sector "Total net emissions (UNFCCC)" for each country
countries_net_corr = emissions_gdp_var.loc[sector].reset_index().groupby("Country").apply(lambda x: x[["per_capita_emiss_variation", "per_capita_GDP_var"]].corr().iloc[1,0])

# plotting
for country in countries:
    country_data = emissions_gdp_var.loc[sector].loc[country]
    country_data.plot.scatter(x = "per_capita_GDP_var", y = "per_capita_emiss_variation", title = country + "\n" + sector)
    plt.axhline(y=0, color='red', linestyle='--')
    plt.axvline(x=0, color='red', linestyle='--')
    plt.text(x = country_data["per_capita_GDP_var"].min(), y = country_data["per_capita_emiss_variation"].max(), s = f"corr. = {countries_net_corr[country]:.2f}", c = "black")
    for i, row in country_data.iterrows():
        plt.text(row['per_capita_GDP_var'], row['per_capita_emiss_variation'], f'{i}', ha='left', fontsize = 8)
    plt.show()

# computing the correlation between "per_capita_emiss_variation" and "per_capita_GDP_var" for each country for the sector total emissions
countries_total_corr = emissions_gdp_var.loc["Total emissions (UNFCCC)"].reset_index().groupby("Country").apply(lambda x: x[["per_capita_emiss_variation", "per_capita_GDP_var"]].corr().iloc[0,1])
countries_total_corr.sort_values(ascending = False)

"""If the outlier year '2020,' characterized by the COVID-19 pandemic lockdown, is excluded from the correlation calculation, distinct correlation values are obtained, as displayed below:"""

wo_2020 = emissions_gdp_var.loc["Total emissions (UNFCCC)"].reset_index()[emissions_gdp_var.loc["Total emissions (UNFCCC)"].reset_index().Year <2020].groupby("Country").apply(lambda x: x[["per_capita_emiss_variation", "per_capita_GDP_var"]].corr().iloc[1,0]).sort_values(ascending = False)
NET_wo_2020 = emissions_gdp_var.loc["Total net emissions (UNFCCC)"].reset_index()[emissions_gdp_var.loc['Total net emissions (UNFCCC)'].reset_index().Year <2020].groupby("Country").apply(lambda x: x[["per_capita_emiss_variation", "per_capita_GDP_var"]].corr().iloc[1,0]).sort_values(ascending = False)
Corr_df = DataFrame([countries_total_corr,countries_net_corr,wo_2020,NET_wo_2020]).T.rename(columns = {0: "Total emissions", 1: "Total NET emissions", 2:"Total w/o 2020", 3:"Total NET w/o 2020"}).sort_values(by="Total emissions",ascending = False)
Corr_df

"""## III.III. Comparison between Sectorial Emissions and GDPs: A Detailed Examination Through Data

In this subsection, our objective is to analyze the classification of the sectors identified in Chapter I within the GDP sectors. The aim is to assess the magnitude to which emissions contribute to the GDPs within each sector.

"""

# List of GDP sectors relevant emissions

'1 - Energy',
'1.A.1 - Energy Industries',
'1.A.2 - Manufacturing Industries and Construction',
'1.A.3 - Transport',
'1.B - Fugitive Emissions from Fuels',
'1.C - CO2 Transport and Storage',

'2 - Industrial Processes and Product Use',
'2.A - Mineral Industry',
'2.B - Chemical Industry',
'2.C - Metal Industry',
    #    '2.D - Non-energy Products from Fuels and Solvent Use',  to be added to  Other Industrial
'2.E - Electronics Industry',
    #    '2.F - Product Uses as Substitutes for ODS', to be added to  Other Industrial
    #    '2.G - Other Product Manufacture and Use', to be added to  Other Industrial
    #    '2.H - Other Industrial Process and Product Use', to be added to Other Industrial

'3 - Agriculture',
'3.1 - Livestock',
'3.B - Manure Management',
'3.C - Rice Cultivation',
'3.D - Agricultural Soils',
    #    '3.E - Prescribed Burning of Savannas', to be added to Other Agriculture
    #    '3.F - Field Burning of Agricultural Residues', to be added to Other Agriculture
    #    '3.G - Liming', to be added to Other Agriculture
    #    '3.H - Urea Application', to be added to Other Agriculture
    #    '3.I - Other Carbon-containing Fertilizers', to be added to Other Agriculture
    #    '3.J - Other agriculture emissions', to be added to Other Agriculture

#  The next ones in item 4 go under agricultures
'4.A - Forest Land',
'4.B - Cropland',
'4.C - Grassland',
'4.D - Wetlands',
'4.G - Harvested Wood Products',

'6 - Other Sector'

"""Firstly, we establish the list of labels contained in *df_emissions_multiindex* that we wish to select. Once done this, we reshape the dataframe to the desired format for our analysis and shift our focus to Italy and the broader European Union."""

correct_list = ['1 - Energy', '1.A.1 - Energy Industries','1.A.2 - Manufacturing Industries and Construction',
            '1.A.3 - Transport', '1.B - Fugitive Emissions from Fuels', '1.C - CO2 Transport and Storage',
            '2 - Industrial Processes and Product Use', '2.A - Mineral Industry','2.B - Chemical Industry',
            '2.C - Metal Industry', '2.E - Electronics Industry', '3 - Agriculture', '3.1 - Livestock',
            '3.B - Manure Management', '3.C - Rice Cultivation', '3.D - Agricultural Soils', '4.A - Forest Land',
            '4.B - Cropland', '4.C - Grassland', '4.D - Wetlands', '4.F - Other Land', '4.G - Harvested Wood Products',
            'Total emissions (UNFCCC)', 'Total net emissions (UNFCCC)']

ita_eu27_emi = df_emissions_multiindex.swaplevel("Country","Pollutant_name").loc["All greenhouse gases - (CO2 equivalent)"].swaplevel("Country","Sector_name").loc[correct_list]

ita_eu27_emi["per_capita_emiss_variation"] = ita_eu27_emi.per_capita_emission.pct_change()
# We add a column that has the percentage variation in emissions from the previous year

# We need to set each row that has year = 1990 to NA
ita_eu27_emi.reset_index(inplace = True)
ita_eu27_emi.set_index("Year", inplace = True)
ita_eu27_emi.loc[1990,"per_capita_emiss_variation"] = np.nan

# After setting the pct variation for 1990 to NA we go back to the original multiindex
ita_eu27_emi.reset_index(inplace = True)
ita_eu27_emi.set_index(["Sector_name","Country","Year"], inplace = True)

# Slicing
ita_eu27_emi = ita_eu27_emi.swaplevel(0,1).loc[["Italy", "EU-27"]]

"""Since not all 172 labels in Chapter I were chosen due to their marginal significance, a custom function is utilized to compute the difference between the main label and each corresponding sub-label. Subsequently, each computed difference is added to our DataFrame."""

# Creating a function to add a new agreggate sector to ita_eu27_emi dataset
def agg_sector(df, country, sector, prefix, new_sector):
  country_sector = df.loc[(country, sector), 'emissions'].groupby('Year').sum()
  country_prefix = df.loc[(country, df.index.get_level_values('Sector_name').str.startswith(prefix)), 'emissions'].groupby('Year').sum()
  new_data = country_sector - country_prefix

  df = df.reset_index()

  new_row_country = pd.DataFrame({
      'Country': country,
      'Sector_name': new_sector,
      'Year': new_data.index,
      'emissions': new_data.values
    })

  df = pd.concat([df, new_row_country], ignore_index=True, sort=False)
  df = df.sort_values(by=['Sector_name', 'Country', 'Year'])
  df.set_index(['Country','Sector_name','Year'], inplace=True)

  pop = df.loc[(country, sector), 'pop_mil']
  df.loc[(country, new_sector), 'pop_mil'] = pop.values

  df['per_capita_emission'] = df['emissions'] / (df['pop_mil'] * 1000000)

  return df

# Adding the new aggregate sector to ita_eu27_emi dataset
ita_eu27_emi = agg_sector(ita_eu27_emi, 'Italy', '1 - Energy', '1.', '1.Extra - Others')
ita_eu27_emi = agg_sector(ita_eu27_emi, 'EU-27', '1 - Energy', '1.', '1.Extra - Others')
ita_eu27_emi = agg_sector(ita_eu27_emi, 'Italy', '2 - Industrial Processes and Product Use', '2.', '2.Extra - Others')
ita_eu27_emi = agg_sector(ita_eu27_emi, 'EU-27', '2 - Industrial Processes and Product Use', '2.', '2.Extra - Others')
ita_eu27_emi = agg_sector(ita_eu27_emi, 'Italy', '3 - Agriculture', '3.', '3.Extra - Others')
ita_eu27_emi = agg_sector(ita_eu27_emi, 'EU-27', '3 - Agriculture', '3.', '3.Extra - Others')

"""After incorporating all the labels identifying the emissions, our objective is to categorize these labels under the sectors utilized in the Percent_GDP DataFrame. To achieve this, we create a dictionary that will be reversed as it aligns more effectively with our goal."""

# Dictionary
dic_gdp_emi = {'Agriculture, forestry and fishing' : ['3.1 - Livestock', '3.B - Manure Management', '3.C - Rice Cultivation',
                                                      '3.D - Agricultural Soils', '4.A - Forest Land', '4.B - Cropland', '4.C - Grassland', '4.D - Wetlands',
                                                      '4.G - Harvested Wood Products','3.Extra - Others','4.F - Other Land'],
               'Construction' : [],
               'Distributive trade, repairs; transport; accommod., food serv.' : ['1.A.3 - Transport',
                                                                                  '1.B - Fugitive Emissions from Fuels', '1.C - CO2 Transport and Storage'],
               'Financial and insurance activities' : [],
               'Gross domestic product' : [],
               'Industry, including energy' : ['1.A.1 - Energy Industries', '1.A.2 - Manufacturing Industries and Construction', '2.A - Mineral Industry',
                                               '2.B - Chemical Industry', '2.C - Metal Industry', '2.E - Electronics Industry', '2.Extra - Others','1.Extra - Others'],
               'Information and communication' : [],
               'Other service activities' : [],
               'Prof., scientific, techn.; admin., support serv. activities' : [],
               'Public admin.; compulsory s.s.; education; human health' : [],
               'Real estate activities' : [],
               'Totals' : ['Total emissions (UNFCCC)','Total net emissions (UNFCCC)']
               }


def invert_dict(dict_to_invert):
    res_dict = dict()
    for key in dict_to_invert:
        for item in dict_to_invert[key]:
            res_dict[item] = key
    return res_dict

print("Sectors included:")
print(*invert_dict(dic_gdp_emi),sep = "\n")
print("-"*120)

gdp_sector = ita_eu27_emi.reset_index().Sector_name.map(invert_dict(dic_gdp_emi))
gdp_sector.index = ita_eu27_emi.index


ita_eu27_emi["gdp_sector"] = gdp_sector

ita_eu27_emi.gdp_sector.value_counts()

# Dropping columns where values is NaN
ita_eu27_emi[ita_eu27_emi.gdp_sector.notna()]

"""From now on, we compute the following results:

* *Total Emissions Percentage*: to understand the proportion of emissions contributed by each sector to the "Total emissions (UNFCCC)" category.

* *Net Emissions Percentage*: to determine the percentage of emissions from each sector in relation to the "Total net emissions (UNFCCC)" category.

*  *GDP Percentage*: reporting the GDP percentage already calculated in the *Percent_GDP* DataFrame for each emissions category categorized under a GDP sector.

*  *Total Emission on Total GDP for Each Subsection*: evaluating how much the total emissions for each subsection contribute to the total GDP sector.

*  *Total Net Emission on Total GDP for Each Subsection*: Assessing the impact of total net emissions for each subsection on the total GDP sector.for each subsection.
"""

# Computing total emissions denominator
series_total = ita_eu27_emi.swaplevel(0,1).loc['Total emissions (UNFCCC)', "emissions"]
tot_denominator = []
for sector in ita_eu27_emi.index.get_level_values("Sector_name").unique():
  tot_denominator.extend(series_total)

# Computing total net emissions denominator
series_total = ita_eu27_emi.swaplevel(0,1).loc['Total net emissions (UNFCCC)', "emissions"]
net_denominator = []
for sector in ita_eu27_emi.index.get_level_values("Sector_name").unique():
  net_denominator.extend(series_total)

# Computing tot_emiss_%
ita_eu27_emi = ita_eu27_emi.swaplevel(0,1)
ita_eu27_emi["tot_emiss_%"] = ita_eu27_emi["emissions"]/tot_denominator
ita_eu27_emi['tot_emiss_%'].loc['Total net emissions (UNFCCC)'] = np.nan
ita_eu27_emi = ita_eu27_emi.swaplevel(0,1)

# Computing net_emiss_%
ita_eu27_emi = ita_eu27_emi.swaplevel(0,1)
ita_eu27_emi["net_emiss_%"] = ita_eu27_emi["emissions"]/net_denominator
ita_eu27_emi['net_emiss_%'].loc['Total emissions (UNFCCC)'] = np.nan
ita_eu27_emi = ita_eu27_emi.swaplevel(0,1)

# creating a copy of the previous dataframe
ita_eu27_perc = df_OECD_beuro.copy()

# converting from currency to percents
for el in ita_eu27_perc:
  for i1, i2 in ita_eu27_perc[el].index:
    ita_eu27_perc[el][i1][i2] = (ita_eu27_perc[el][i1][i2])/(df_OECD_beuro["Gross domestic product"][i1][i2])
ita_eu27_perc = ita_eu27_perc.applymap(lambda x: x * 100 if pd.notna(x) else x)
ita_eu27_perc

ita_eu27_perc = ita_eu27_perc.loc[["Italy", "EU-27"]]

ita_eu27_perc.T.loc[['Agriculture, forestry and fishing', 'Industry, including energy', 'Distributive trade, repairs; transport; accommod., food serv.', 'Gross domestic product']].T

# Creating a pass-by dataframe to reassign the values of ita_eu27_perc to a new column in ita_eu27_emi
df_merged = pd.merge(ita_eu27_emi, ita_eu27_perc, left_index=True, right_index=True)
df_result = df_merged.apply(lambda row: row.get(row['gdp_sector'], None), axis=1).reset_index().set_index(['Country', 'Year'])

# Creating the new column "gdp_%" in which are copied the value of Percent_GDP categorized for each emissions' subsection
df_result = df_result.reset_index()
df_result = df_result.set_index(['Country', 'Sector_name', 'Year'])
ita_eu27_emi["gdp_%"] = df_result[0]

# Computing the weight of total emissions for each sector on GDP
ita_eu27_emi["tot_emiss_%/gdp_%"] = (ita_eu27_emi["tot_emiss_%"] * ita_eu27_emi["gdp_%"]) /100

# Computing the weight of total net emissions for each sector on GDP
ita_eu27_emi["net_emiss_%/gdp_%"] = (ita_eu27_emi["net_emiss_%"] * ita_eu27_emi["gdp_%"]) / 100

ita_eu27_emi_2 = ita_eu27_emi.copy()

ita_eu27_emi_2 = ita_eu27_emi_2[ita_eu27_emi_2.gdp_sector.notna()]

# The difference between ita_eu27_emi_2 and ita_eu27_emi is that we removed the ghg sectors that do not belong to any gdp sector
print(ita_eu27_emi_2.gdp_sector.isna().sum())
ita_eu27_emi.gdp_sector.isna().sum()

"""Now we plot the total emissions as a percentage of the GDP.

The shallow represent the I.C. given by the data for the same year
"""

ita_eu27_emi_reset = ita_eu27_emi_2.loc["Italy"].reset_index()


plt.figure(figsize=(7, 5))
sns.lineplot(x='Year', y= 'tot_emiss_%/gdp_%', hue = 'gdp_sector', data = ita_eu27_emi_reset, marker='o')


# plt.ylim(-0.001, 0.001)
plt.title('EU-27' + '\n' + '%Tot. emissions/%GDP', fontsize = 16)
plt.xlabel('Year')
plt.ylabel('Total Emissions as a Percentage of GDP')
plt.legend(title='GDP Sector', loc='upper left', bbox_to_anchor=(1, 1), frameon = False)
plt.grid(True, color = 'grey')
plt.savefig('EU_ita_eu27_emi_plot.svg', format='svg', facecolor=(1, 1, 1, 0), transparent=True, bbox_inches='tight')

ita_eu27_emi_reset = ita_eu27_emi_2.loc["Italy"].reset_index()


plt.figure(figsize=(7, 5))
sns.lineplot(x='Year', y= 'tot_emiss_%', hue = 'gdp_sector', data = ita_eu27_emi_reset, marker='o')


plt.ylim(-0.03, 0.26)
plt.title('Italy' + '\n' + '%Tot. emissions/%GDP', fontsize = 16)
plt.xlabel('Year')
plt.ylabel('Total Emissions as a Percentage of GDP')
plt.legend(title='GDP Sector', loc='upper left', bbox_to_anchor=(1, 1), frameon = False)
plt.grid(True, color = "grey")
plt.savefig('ITA_ita_eu27_emi_plot.svg', format='svg', facecolor=(1, 1, 1, 0), transparent=True, bbox_inches='tight')

"""Here we plot the evolution of *net_emiss_%* and *gdp_%* for Italy and EU-27"""

# Italy
sub_selection = ita_eu27_emi_2.loc["Italy"][["gdp_sector",'net_emiss_%',"gdp_%"]].reset_index().set_index(["gdp_sector","Year"])
# sub_selection

fig, axes = plt.subplots(3,1)
axes = axes.flatten()
for i,sector in enumerate(["Agriculture, forestry and fishing","Industry, including energy",'Distributive trade, repairs; transport; accommod., food serv.']):
    ax = axes[i]
    sub_selection.reset_index().groupby(["gdp_sector","Year"]).apply(lambda group : (group["net_emiss_%"].sum())*100).loc[sector].plot(ax = ax, label = "Net Emissions",marker='|')
    sub_selection.reset_index().groupby(["gdp_sector","Year"]).apply(lambda group : group["gdp_%"].min()).loc[sector].plot(ax = ax, label = "GDP",marker='|')

    ax.set_title(sector)
    ax.legend(bbox_to_anchor=(1,1))
plt.tight_layout()
plt.rc('figure', figsize=(7,5))
plt.show()

# EU-27
sub_selection = ita_eu27_emi_2.loc["EU-27"][["gdp_sector",'net_emiss_%',"gdp_%"]].reset_index().set_index(["gdp_sector","Year"])

fig, axes = plt.subplots(3,1)
axes = axes.flatten()
for i,sector in enumerate(["Agriculture, forestry and fishing","Industry, including energy",'Distributive trade, repairs; transport; accommod., food serv.']):
    ax = axes[i]
    sub_selection.reset_index().groupby(["gdp_sector","Year"]).apply(lambda group : (group["net_emiss_%"].sum())*100).loc[sector].plot(ax = ax, label = "Net Emissions",marker='|')
    sub_selection.reset_index().groupby(["gdp_sector","Year"]).apply(lambda group : group["gdp_%"].min()).loc[sector].plot(ax = ax, label = "GDP",marker='|')

    ax.set_title(sector)
    ax.legend(bbox_to_anchor= (1,1))
plt.tight_layout()
plt.rc('figure', figsize=(7, 5))
plt.show()

"""## III.IV GDP Over Emissions: an Inverse Overview of Data

We want now to focus our attention on how much GDP in Euro is produced by a ton of emissions.
"""

# creating a new DataFrame
gdp_values = df_OECD_aeuro.loc[["Italy","EU-27"]][["Agriculture, forestry and fishing","Industry, including energy",'Distributive trade, repairs; transport; accommod., food serv.',"Gross domestic product"]].stack()
gdp_values = gdp_values.reset_index()
gdp_values = gdp_values[gdp_values.Year < 2022]

thing_to_concat = gdp_values[gdp_values.Sectors == "Gross domestic product"].copy()
thing_to_concat.Sectors = "Total emissions (UNFCCC)"

gdp_values = pd.concat([gdp_values, thing_to_concat])
gdp_values.loc[gdp_values.Sectors == "Gross domestic product","Sectors"] = "Total net emissions (UNFCCC)"
gdp_values.rename(columns = {"Sectors": "gdp_sector"},inplace = True)
gdp_values.set_index(["Country","gdp_sector","Year"],inplace = True)
gdp_values.rename(columns = {0: "gdp"},inplace = True)

emissions_values = ita_eu27_emi_2[["emissions","gdp_sector"]].copy().reset_index()
emi_no_totals = emissions_values[emissions_values.gdp_sector.isin(["Agriculture, forestry and fishing","Industry, including energy",'Distributive trade, repairs; transport; accommod., food serv.'])]
emi_no_totals = emi_no_totals[emi_no_totals.Year > 2001]
emi_no_totals = emi_no_totals.groupby(["Country","Year","gdp_sector"]).emissions.sum()
emi_no_totals = emi_no_totals.reset_index()

emi_only_totals = emissions_values[~emissions_values.gdp_sector.isin(["Agriculture, forestry and fishing","Industry, including energy",'Distributive trade, repairs; transport; accommod., food serv.'])]
emi_only_totals = emi_only_totals[emi_only_totals.Year > 2001]
emi_only_totals.drop(columns ="gdp_sector",inplace = True)
emi_only_totals.rename(columns = {"Sector_name": "gdp_sector"},inplace = True)
emi_only_totals
emissions_values = pd.concat([emi_no_totals, emi_only_totals])
emissions_values.set_index(["Country","gdp_sector","Year"],inplace = True)

gdp_ghg_absvals = pd.merge(emissions_values.emissions, gdp_values["gdp"] ,left_index = True, right_index = True)

# now I calculate the ratio between gdp in euros and emissions in tons
gdp_ghg_absvals["gdp_over_emissions"] = (gdp_ghg_absvals.gdp*1000000)/(gdp_ghg_absvals.emissions*1000)
gdp_ghg_absvals.loc["Italy"].loc["Total net emissions (UNFCCC)"]

country = "Italy"
gdp_sector = "Total net emissions (UNFCCC)"
gdp_ghg_absvals.loc[(country,gdp_sector)].gdp_over_emissions.pow(-1)

gdp_ghg_absvals.index.get_level_values("gdp_sector").value_counts()
#the dataframe has years from 2002 to 2021, for two countries: Ita and EU-27, for 5 sectors: the 3 gdp sectors plus net emissions and total emiss

#plotting the evolution
plt.plot(gdp_ghg_absvals.loc["Italy"].loc["Total net emissions (UNFCCC)"]['gdp_over_emissions'], label = 'Italy gdp_over_emissions', marker = '|')
plt.plot(gdp_ghg_absvals.loc["EU-27"].loc["Total net emissions (UNFCCC)"]['gdp_over_emissions'], label = 'EU-27 gdp_over_emissions', marker = '|')
plt.legend(bbox_to_anchor = (1,1))
plt.xticks(range(2002, 2022), rotation=30)
plt.show()

# adding variation columns
gdp_ghg_absvals['emissions_var']= gdp_ghg_absvals.groupby(['Country',  'gdp_sector'])['emissions'].pct_change()
gdp_ghg_absvals['gdp_var'] = gdp_ghg_absvals.groupby(['Country',  'gdp_sector'])['gdp'].pct_change()
gdp_ghg_absvals

# computing correlations
correlation_by_sector = pd.DataFrame(gdp_ghg_absvals.groupby(['Country', 'gdp_sector']).corr().unstack()['emissions_var']['gdp_var'])
correlation_by_sector['gdp_emi_corr'] = correlation_by_sector['gdp_var']
del correlation_by_sector['gdp_var']
correlation_by_sector

"""# IV° Chapter

On the aforementioned data, we want now to do a Linear Regression Analysis.

## IV.I. Linear Regression
"""

X = DataFrame(emissions_gdp_var.loc['Total emissions (UNFCCC)'].per_capita_GDP_var)
y = DataFrame(emissions_gdp_var.loc['Total emissions (UNFCCC)'].per_capita_emiss_variation)

# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2)

model = LinearRegression()
model.fit(X, y)

y_prediction = model.predict(X)
mse = metrics.mean_squared_error(y, y_prediction)
r2 = metrics.r2_score(y, y_prediction)

r2
# mse

plt.scatter(X, y, color = 'black')
plt.plot(X, y_prediction, color='blue', label='Regressione lineare')
plt.xlabel('per_capita_GDP_var')
plt.ylabel('per_capita_emiss_variation')
plt.legend()
plt.show()

print('regr.coef: ' , model.coef_)
print('regr.intercept: ' , model.intercept_)
print('r2: ', r2)
print('mse: ', mse)

"""Testing the null hypothesis that the coefficient is equal to 0:

$\hat{SE}(β_1)^2 = \frac{\hat{σ}^2}{\sum^n_{x_i}(x_i -\overline{x})^2}$

where $\hat{σ}^2 = RSS/(n − 2)$


$t = \frac{\hat β_1 - 0}{SE(\hat β_1)}$
"""

# numerator
num = np.sum((y-model.predict(X))**2)[0]/(y.size-2)
# denominator
den = np.sum((np.asarray(X)-X.mean()[0])**2)
se_coef = np.sqrt(num/den)

t_test = model.coef_[0]/se_coef
t_test[0]

"""The T-test value is high, that means that the p-value is low.
For this reason, we can reject the null hypothesis. The slope of the line is not 0
"""

# Same regression but different sector: now total net instead of total emissions

X = DataFrame(emissions_gdp_var.loc['Total net emissions (UNFCCC)'].per_capita_GDP_var)
y = DataFrame(emissions_gdp_var.loc['Total net emissions (UNFCCC)'].per_capita_emiss_variation)

model = LinearRegression()
model.fit(X, y)

y_prediction = model.predict(X)
mse = metrics.mean_squared_error(y, y_prediction)
r2 = metrics.r2_score(y, y_prediction)

print("r2 = ", r2, " \n mse = ", mse)


plt.scatter(X, y, color = 'black')
plt.plot(X, y_prediction, color='blue', label='Regressione lineare')
plt.xlabel('per_capita_GDP_var')
plt.ylabel('per_capita_emiss_variation')
plt.legend()
plt.title('Total net emissions (UNFCCC)')
plt.show()

print('regr.coef: ' , model.coef_)
print('regr.intercept: ' , model.intercept_)
print('r2: ', r2)
print('mse: ', mse)

"""## IV.II. Classification
Can we predict if, in a given year, per capita emissions of all GHG will decrease (positive result) or increase (negative result)?

We will make a binary classifier using logistic regression.
The Y variable we are modeling is defined as:

𝗬 = 𝑰(Δ per capita emissions ≤ 0)


"""

# Binary classifier
y = np.array(emissions_gdp_var.loc['Total emissions (UNFCCC)'].per_capita_emiss_variation <= 0)
X = emissions_gdp_var.loc['Total emissions (UNFCCC)'][["per_capita_GDP_var","per_capita_GDP"]]

logreg= LogisticRegression()
logreg.fit(X, y)

y_prediction = logreg.predict(X)

print('Accuracy: ',metrics.accuracy_score(y, y_prediction))
print('Recall: ',metrics.recall_score(y, y_prediction, zero_division=1))
print('Precision: ' ,metrics.precision_score(y, y_prediction, zero_division=1))
print('CL Report \n',metrics.classification_report(y, y_prediction, zero_division=1))

y.sum()/y.size

y_pred_proba= logreg.predict_proba(X) [::,1]
false_positive_rate, true_positive_rate, *rest  = metrics.roc_curve(y, y_pred_proba)
auc= metrics.roc_auc_score(y, y_pred_proba)
plt.plot(false_positive_rate, true_positive_rate,label="AUC="+str(auc))
plt.title('ROC Curve')
plt.ylabel('True Positive Rate')
plt.xlabel('false Positive Rate')
plt.legend(loc=4)

clf = SVC()
clf.fit(X, y)
predictions = clf.predict(X)
cm = confusion_matrix(y, predictions, labels=clf.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=cm,display_labels=clf.classes_)
disp.plot(cmap=plt.cm.Greens)
plt.savefig("ConfusMatrx.svg", facecolor=(1, 1, 1, 0), transparent=True, bbox_inches='tight')
plt.show()

# This is a binary classifier that has per capita emissions variation as response variable y and per capita gdp variation as the only X

plt.rc('figure', figsize=(6, 4))

for sector in emissions_gdp_var.index.get_level_values("Sector_name").unique():
    X = emissions_gdp_var.loc[sector][["per_capita_GDP_var"]]
    y = np.asarray(emissions_gdp_var.loc[sector].per_capita_emiss_variation<=0)
    # A positive value means that percapita emissions decreased from the previous year

    model = LogisticRegression()
    model.fit(X,y)
    y_pred_proba= model.predict_proba(X) [::,1]
    false_positive_rate, true_positive_rate, other_values  = metrics.roc_curve(y, y_pred_proba)
    auc= metrics.roc_auc_score(y, y_pred_proba)

    plt.plot(false_positive_rate, true_positive_rate, label="AUC="+str(auc))
    plt.title(sector + "\n" +'ROC Curve')
    plt.ylabel('True Positive Rate')
    plt.xlabel('false Positive Rate')
    plt.legend(loc=4)
    plt.plot([0,1],[0,1])
    plt.show()
    print(sector," \tThe proportion of positives is ",y.sum()/y.size)
    print(sector," \tThe precision score is",metrics.precision_score(y,model.predict(X),zero_division = 1))
    print(sector," \tThe accuracy score is", metrics.accuracy_score(y,model.predict(X)))
    print("-"*100)

#Same as above but we use two X variables: we add per_capita_gdp

plt.rc('figure', figsize=(6, 4))

for sector in emissions_gdp_var.index.get_level_values("Sector_name").unique():
    X = emissions_gdp_var.loc[sector][["per_capita_GDP_var","per_capita_GDP"]]
    y = np.asarray(emissions_gdp_var.loc[sector].per_capita_emiss_variation<=0)
    # A positive value means that percapita emissions decreased from the previous year

    model = LogisticRegression()
    model.fit(X,y)
    y_pred_proba= model.predict_proba(X) [::,1]
    false_positive_rate, true_positive_rate, other_values  = metrics.roc_curve(y, y_pred_proba)
    auc= metrics.roc_auc_score(y, y_pred_proba)

    plt.plot(false_positive_rate, true_positive_rate, label="AUC="+str(auc))
    plt.title(sector + "\n" +'ROC Curve')
    plt.ylabel('True Positive Rate')
    plt.xlabel('false Positive Rate')
    plt.legend(loc=4)
    plt.plot([0,1],[0,1])
    plt.show()
    print(sector," \tThe proportion of positives is ",y.sum()/y.size)
    print(sector," \tThe precision score is",metrics.precision_score(y,model.predict(X),zero_division = 1))
    print(sector," \tThe accuracy score is", metrics.accuracy_score(y,model.predict(X)))
    print("-"*100)

"""adding per capita gdp to the X matrix doesn't improve the classifier

"""

df_emissions_multiindex.index.names

"""# Graphs we added to the presentation"""

countries = ["Italy", "EU-27","Germany"]
pollutant = "All greenhouse gases - (CO2 equivalent)" # I'm not yet looking at other Greenhouse Gases
chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']

def get_smaller_df(country, pollutant, sector):
    return df_emissions_multiindex.loc[country, pollutant, sector].copy()

plt.rc('figure', figsize = (16,7))
fig = plt.figure()
axes = [fig.add_subplot(2, 2, i) for i in range(1,4)]
fig.subplots_adjust(hspace=.4)
for i,country in enumerate(countries):
    for sector in chosen_sectors:
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            axes[i].plot(df_to_plot.emissions/1000, label = sector, marker = "|")
        except KeyError:
            print(country, pollutant, sector ," was not found")
    axes[i].set_title(country +"\n "+ pollutant + "\n millions of tons")
plt.legend(bbox_to_anchor=(1.2,1),fontsize = 15, frameon=False)
plt.show()
fig.savefig("allghg_countries_sector.svg", facecolor = (1,1,1,0), transparent = True)

countries = ['Italy', 'Ireland', 'Sweden', 'Germany', "Spain","France"]
chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']
pollutant = "All greenhouse gases - (CO2 equivalent)" # I'm not yet looking at other Greenhouse Gases

def get_smaller_df(country, pollutant, sector):
    return df_emissions_multiindex.loc[country, pollutant, sector].copy()

plt.rc('figure', figsize = (18,8))

fig = plt.figure()
axes = [fig.add_subplot(2, 4, i) for i in range(1,8)]
fig.subplots_adjust(hspace=.4)


for i,sector in enumerate(chosen_sectors):
    for country in countries:
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            axes[i].plot(df_to_plot.emissions/1000,label = country, marker = "|")
        except KeyError:
            print(country, pollutant, sector, "gave a key error")
        axes[i].set_title(sector + "\n" + pollutant + "\nmillions of tons",fontsize = 10)
plt.legend(loc= "lower right",bbox_to_anchor=(2, 0.2), fontsize = 18, frameon= False)
plt.show()
fig.savefig("allghg_sectors_countries_sidebyside.svg", facecolor = (1,1,1,0), transparent = True)

# GDP variations over years
fig, ax = plt.subplots(1, figsize = (9.5,5))
for el in GDP_Var:
    plt.plot(GDP_Var[el], label=el, marker = '|')
    plt.legend(title='Country', bbox_to_anchor=(1.65, 1), ncol = 4, fontsize = "small")
    plt.xlabel('Year')
    plt.ylabel('Growth of GDP')
    plt.ylim(-0.3, 0.4)
    x_lab = GDP_Var.index
    ticks = ax.set_xticks(x_lab)
plt.xticks(range(2002, 2023, 4))
plt.show()
fig.savefig("GDP_Var.svg", facecolor=(1, 1, 1, 0), transparent=True, bbox_inches='tight')

# Choroplet map
mask = df_Eurostat['TIME_PERIOD'].isin(range(2002,2023))
df_to_plot = df_Eurostat[mask]

fig = px.choropleth(df_to_plot.sort_values('TIME_PERIOD'),
                    locations = "geo",
                    range_color = (0, 3000000),
                    color  ="OBS_VALUE",
                    color_continuous_scale = "Hot",
                    scope = "europe",
                    animation_frame = "TIME_PERIOD")

fig.update_geos(fitbounds="locations", visible=True)
fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
fig.write_html('Eurostat_choro.html')
fig.show()

# different pollutants= Co2 is the main one, the other ones have a really small impact on All GhG

chosen_countries = ["Italy","EU-27"]
sector = 'Total net emissions (UNFCCC)'
chosen_pollutants = ["CH4","N2O","PFCs - (CO2 equivalent)","HFCs - (CO2 equivalent)","SF6 - (CO2 equivalent)","Unspecified mix of HFCs and PFCs - (CO2 equivalent)","NF3 - (CO2 equivalent)","All greenhouse gases - (CO2 equivalent)","CO2"]
colors = {
    "All greenhouse gases - (CO2 equivalent)":"blue",
    "CH4":"green",
    "CO2":"orange",
    "N2O":"red",
    "PFCs - (CO2 equivalent)":"purple",
    "HFCs - (CO2 equivalent)":"brown",
    "SF6 - (CO2 equivalent)":"pink",
    "Unspecified mix of HFCs and PFCs - (CO2 equivalent)":"gray",
    "NF3 - (CO2 equivalent)":"olive"
}


def get_smaller_df(country, pollutant, sector):
    return df_emissions_multiindex.loc[country, pollutant, sector].copy()

plt.rc('figure', figsize = (14,5))

fig = plt.figure()
axes = [fig.add_subplot(1, 5, i) for i in range(1,5)]
fig.subplots_adjust(wspace=.3)

for i, country in enumerate(chosen_countries):
    for pollutant in sorted(chosen_pollutants):
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            axes[i].plot(df_to_plot.emissions/1000,label = pollutant, marker = '|',color = colors[pollutant])
        except KeyError:
            print(country, pollutant, sector, "gave a key error")
    axes[i].set_title(sector + "\n" + country + "\nmillions of tons", fontsize = 10)
axes[0].legend(loc="right",bbox_to_anchor=(6.9,0.5),fontsize = 8, frameon= False)


chosen_countries = ["Italy","EU-27"]
sector = 'Total net emissions (UNFCCC)'
chosen_pollutants = ["CH4","N2O","PFCs - (CO2 equivalent)","HFCs - (CO2 equivalent)","SF6 - (CO2 equivalent)","Unspecified mix of HFCs and PFCs - (CO2 equivalent)","NF3 - (CO2 equivalent)"]

for i, country in enumerate(chosen_countries):
    for j,pollutant in enumerate(chosen_pollutants):
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            axes[i+2].plot(df_to_plot.emissions/1000,label = pollutant, marker = '|',color = colors[pollutant])
        except KeyError:
            print(country, pollutant, sector, "gave a key error")
    axes[i+2].set_title(sector + "\n" + country + "\nmillions of tons",fontsize = 10)

plt.show()
fig.savefig("different_gases.svg", facecolor = (1,1,1,0), transparent = True, pad_inches= 4)

# per capita plots


countries = ['Italy', 'Ireland', 'Sweden', 'Germany', "Spain","France","EU-27"]
pollutant = "All greenhouse gases - (CO2 equivalent)"
chosen_sectors = ['1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management','Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)',]


plt.rc('figure', figsize = (18,8))

fig = plt.figure()
axes = [fig.add_subplot(2, 4, i) for i in range(1,8)]
fig.subplots_adjust(hspace=.4)

for i,sector in enumerate(chosen_sectors):
    for country in countries:
        try:
            df_to_plot = get_smaller_df(country, pollutant, sector)
            axes[i].plot(df_to_plot.per_capita_emission*1000, label = country, marker = '|')
        except KeyError:
            print(country, pollutant, sector ," was not found")
        axes[i].set_title(sector + "\n"+  pollutant + "\ntons per capita",fontsize = 10)
plt.legend(loc= "lower right",bbox_to_anchor=(2, 0.2), fontsize = 18, frameon= False)

plt.show()
fig.savefig("percapita.svg", facecolor = (1,1,1,0), transparent = True)

countries = ["Italy", "EU-27"]
sector = "Total net emissions (UNFCCC)"

plt.rc('figure', figsize = (15,6))

fig = plt.figure()
axes = [fig.add_subplot(1, 2, i) for i in range(1,3)]
fig.subplots_adjust(wspace=.2)

for i, country in enumerate(countries):
    ax = axes[i]
    x = emissions_gdp_var.loc[sector].loc[country].per_capita_GDP_var
    y = emissions_gdp_var.loc[sector].loc[country].per_capita_emiss_variation
    ax.scatter(x,y,color = "green")
    ax.set_ylabel("ΔGHG per capita")
    ax.set_xlabel("ΔGDP per capita")
    ax.set_title(f"{country}")
    ax.axhline(y=0, color='blue', linestyle='--', linewidth = .6)
    ax.axvline(x=0, color='blue', linestyle='--', linewidth = .6)
    ax.text(x = x.min(), y = y.max(), s = f"corr. = {x.corr(y):.3f}", c = "black")
    for i, row in emissions_gdp_var.loc[sector].loc[country].iterrows():
        ax.text(row['per_capita_GDP_var'],row['per_capita_emiss_variation'], f'{i}', ha='left', fontsize = 6)
fig.savefig("scatter_gdp_ghg_variation.svg", facecolor = (1,1,1,0), transparent = True)

# creating a scatterplot for each sector
countries = emissions_gdp_var.index.get_level_values('Country').unique()
colors = [plt.get_cmap("Greens")(i/28) for i in range(countries.size)]

chosen_sectors = ['Total net emissions (UNFCCC)', 'Total emissions (UNFCCC)','1 - Energy','2 - Industrial Processes and Product Use','3 - Agriculture','4 - Land Use, Land-Use Change and Forestry','5 - Waste management']
plt.rc('figure', figsize = (18,8))

fig = plt.figure()
axes = [fig.add_subplot(2, 4, i) for i in range(1,8)]
fig.subplots_adjust(wspace=.4,hspace = .4)

for i, sector in enumerate(chosen_sectors):
    ax = axes[i]
    ax.set_title(sector,color = "white")
    for j,country in enumerate(countries):
      country_data = emissions_gdp_var.loc[sector].loc[country]
      ax.scatter(x=country_data['per_capita_GDP_var'], y=country_data['per_capita_emiss_variation'], label=country, color= colors[j], s=1)

    ax.set_ylim(-0.2,0.2)
    ax.set_ylabel("ΔGHG per capita", color = "white")
    ax.set_xlabel("ΔGDP per capita",color = "white")
    ax.text(x = -0.3, y = 0.175, s = f"corr. = {sectors_corr[sector]:.2f}", c = "white")

    ax.spines['bottom'].set_color('white')
    ax.spines['top'].set_color('white')
    ax.spines['right'].set_color('white')
    ax.spines['left'].set_color('white')
    ax.tick_params(axis='x', colors='white')
    ax.tick_params(axis='y', colors='white')
    ax.yaxis.label.set_color('white')
    ax.xaxis.label.set_color('white')

legend = axes[6].legend(loc='right', bbox_to_anchor=(2.4, .5), ncol=3, fontsize=8,frameon = False)
for text in legend.get_texts():
    text.set_color("white")
plt.show()
fig.savefig("scatter_by_sectors.svg", facecolor = (1,1,1,0), transparent = True)

#Net emissions of particular countryes
sector = "Total net emissions (UNFCCC)"
countries = ['Malta', 'Latvia', 'Finland', 'Denmark']

plt.rc('figure', figsize=(7, 5))
for country in countries:
    country_data = emissions_gdp_var.loc[sector].loc[country]
    country_data.plot.scatter(x = "per_capita_GDP_var", y = "per_capita_emiss_variation", title = country + "\n" + sector, c = 'green')
    plt.axhline(y=0, color='blue', linestyle='--')
    plt.axvline(x=0, color='blue', linestyle='--')
    plt.text(x = country_data["per_capita_GDP_var"].min(), y = country_data["per_capita_emiss_variation"].max(), s = f"corr. = {countries_net_corr[country]:.2f}", c = "black")
    plt.ylabel("ΔGHG per capita")
    plt.xlabel("ΔGDP per capita")
    for i, row in country_data.iterrows():
        plt.text(row['per_capita_GDP_var'], row['per_capita_emiss_variation'], f'{i}', ha='left', fontsize = 8)
    plt.savefig(str(country + '.svg'), facecolor=(1, 1, 1, 0), transparent=True, bbox_inches='tight')
    plt.show()

ita_eu27_emi_reset = ita_eu27_emi_2.loc["Italy"].reset_index()


plt.figure(figsize=(7, 5))
sns.lineplot(x='Year', y= 'tot_emiss_%', hue = 'gdp_sector', data = ita_eu27_emi_reset, marker='o')


plt.ylim(-0.03, 0.26)
plt.title('Italy' + '\n' + '%Tot. emissions/%GDP', fontsize = 16)
plt.xlabel('Year')
plt.ylabel('Total Emissions as a Percentage of GDP')
plt.legend(title='GDP Sector', loc='upper left', bbox_to_anchor=(1, 1), frameon = False)
plt.grid(True, color = "grey")
plt.savefig('ITA_ita_eu27_emi_plot.svg', format='svg', facecolor=(1, 1, 1, 0), transparent=True, bbox_inches='tight')

ita_eu27_emi_reset = ita_eu27_emi_2.loc["Italy"].reset_index()


plt.figure(figsize=(7, 5))
sns.lineplot(x='Year', y= 'tot_emiss_%/gdp_%', hue = 'gdp_sector', data = ita_eu27_emi_reset, marker='o')


# plt.ylim(-0.001, 0.001)
plt.title('EU-27' + '\n' + '%Tot. emissions/%GDP', fontsize = 16)
plt.xlabel('Year')
plt.ylabel('Total Emissions as a Percentage of GDP')
plt.legend(title='GDP Sector', loc='upper left', bbox_to_anchor=(1, 1), frameon = False)
plt.grid(True, color = 'grey')
plt.savefig('EU_ita_eu27_emi_plot.svg', format='svg', facecolor=(1, 1, 1, 0), transparent=True, bbox_inches='tight')

# Italy
sub_selection = ita_eu27_emi_2.loc["Italy"][["gdp_sector",'net_emiss_%',"gdp_%"]].reset_index().set_index(["gdp_sector","Year"])
# sub_selection

colors = {'Net Emissions': 'green', 'GDP': 'orange'}

fig, axes = plt.subplots(3,1)
axes = axes.flatten()
for i,sector in enumerate(["Agriculture, forestry and fishing","Industry, including energy",'Distributive trade, repairs; transport; accommod., food serv.']):
    ax = axes[i]
    sub_selection.reset_index().groupby(["gdp_sector","Year"]).apply(lambda group : (group["net_emiss_%"].sum())*100).loc[sector].plot(ax = ax, label = "Net Emissions",marker='|', color=colors['Net Emissions'])
    sub_selection.reset_index().groupby(["gdp_sector","Year"]).apply(lambda group : group["gdp_%"].min()).loc[sector].plot(ax = ax, label = "GDP",marker='|', color=colors['GDP'])

    ax.set_title(sector)
    ax.legend(bbox_to_anchor=(1,1), frameon = False)
plt.tight_layout()
plt.rc('figure', figsize=(7,5))
plt.savefig("ITA_GDP_emisionss_path.svg", facecolor = (1,1,1,0), transparent = True)

# EU-27
sub_selection = ita_eu27_emi_2.loc["EU-27"][["gdp_sector",'net_emiss_%',"gdp_%"]].reset_index().set_index(["gdp_sector","Year"])

colors = {'Net Emissions': 'green', 'GDP': 'orange'}

fig, axes = plt.subplots(3,1)
axes = axes.flatten()
for i,sector in enumerate(["Agriculture, forestry and fishing","Industry, including energy",'Distributive trade, repairs; transport; accommod., food serv.']):
    ax = axes[i]
    sub_selection.reset_index().groupby(["gdp_sector","Year"]).apply(lambda group : (group["net_emiss_%"].sum())*100).loc[sector].plot(ax = ax, label = "Net Emissions",marker='|', color=colors['Net Emissions'])
    sub_selection.reset_index().groupby(["gdp_sector","Year"]).apply(lambda group : group["gdp_%"].min()).loc[sector].plot(ax = ax, label = "GDP",marker='|', color=colors['GDP'])

    ax.set_title(sector)
    ax.legend(bbox_to_anchor= (1,1), frameon = False)
plt.tight_layout()
plt.rc('figure', figsize=(7, 5))
plt.savefig("EU_GDP_emisionss_path.svg", facecolor = (1,1,1,0), transparent = True, bbox_inches='tight')

#plotting the evolution of NEt emissions over GDP
colors = {'Italy gdp_over_emissions': '#00008B', 'EU-27 gdp_over_emissions': '#006400'}
plt.rc('figure', figsize = (10,2))
plt.plot(gdp_ghg_absvals.loc["Italy"].loc["Total net emissions (UNFCCC)"]['gdp_over_emissions'], label = 'Italy gdp_over_emissions', marker = '|', color = colors['Italy gdp_over_emissions'])
plt.plot(gdp_ghg_absvals.loc["EU-27"].loc["Total net emissions (UNFCCC)"]['gdp_over_emissions'], label = 'EU-27 gdp_over_emissions', marker = '|', color = colors['EU-27 gdp_over_emissions'])
plt.legend(bbox_to_anchor = (1,1), frameon = False)
plt.xticks(range(2002, 2022), rotation=30)
plt.savefig("evolution.svg", facecolor = (1,1,1,0), transparent = True, bbox_inches='tight')

plt.rc('figure', figsize=(18, 10))

fig = plt.figure()
axes = [fig.add_subplot(2, 4, i) for i in range(1,8)]
fig.subplots_adjust(hspace=.4)

for i,sector in enumerate(emissions_gdp_var.index.get_level_values("Sector_name").unique()):
    X = emissions_gdp_var.loc[sector][["per_capita_GDP_var"]]
    y = np.asarray(emissions_gdp_var.loc[sector].per_capita_emiss_variation<=0)
    # A positive value means that percapita emissions decreased from the previous year

    model = LogisticRegression()
    model.fit(X,y)
    y_pred_proba= model.predict_proba(X)[::,1]
    false_positive_rate, true_positive_rate, other_values  = metrics.roc_curve(y, y_pred_proba)
    auc= metrics.roc_auc_score(y, y_pred_proba)
    ax = axes[i]
    ax.plot(false_positive_rate, true_positive_rate, label="AUC="+str(round(auc,3)))
    ax.set_title(sector + "\n" +'ROC Curve')
    ax.set_ylabel('True Positive Rate')
    ax.set_xlabel('False Positive Rate')
    ax.legend(loc=4)
    ax.plot([0,1],[0,1])

    fig.savefig("roc_curves.svg", facecolor = (1,1,1,0), transparent = True)